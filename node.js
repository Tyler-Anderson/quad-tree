// Generated by CoffeeScript 1.10.0
(function() {
  var Node;

  Node = (function() {
    function Node(x, y, w, h, depth, maxChildren, maxDepth) {
      var BOTTOM_LEFT, BOTTOM_RIGHT, PARENT, TOP_LEFT, TOP_RIGHT;
      this.children = [];
      this.nodes = [];
      this.x = x;
      this.y = y;
      ({
        w: w,
        h: h,
        depth: depth
      });
      TOP_LEFT = 0;
      TOP_RIGHT = 1;
      BOTTOM_LEFT = 2;
      BOTTOM_RIGHT = 3;
      PARENT = 4;
      if (this.maxDepth == null) {
        this.maxDepth = 7;
      }
      if (this.maxChildren == null) {
        this.maxChildren = 4;
      }
    }

    Node.prototype.retrieve = function(item) {
      var i, j, ref, results;
      results = [];
      for (i = j = 0, ref = children.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (this.nodes.length) {
          results.push(this.findOverlappingNodes(item, function(dir) {}, this.nodes[dir].retrieve(item)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.insert = function(item) {
      var i;
      if (this.nodes.length) {
        i = this.findInsertNode(item);
        if (i === PARENT) {
          return this.children.push(item);
        } else {
          return this.nodes[i].insert(item);
        }
      } else {
        this.children.push(item);
        if (this.children.length > this.maxChildren && this.depth > this.maxDepth) {
          console.log('divide, check');
          return this.divide();
        }
      }
    };

    Node.prototype.findInsertNode = function(item) {
      if (item.x + item.w < this.x + (w / 2)) {
        if (item.y + item.h < this.y + (h / 2)) {
          TOP_LEFT;
        }
        if (item.y >= this.y + (h / 2)) {
          BOTTOM_LEFT;
        }
        PARENT;
      }
      if (item.x >= this.x + (w / 2)) {
        if (item.y + item.h < this.y + (h / 2)) {
          TOP_RIGHT;
        }
        if (item.y >= this.y + (h / 2)) {
          BOTTOM_RIGHT;
        }
        PARENT;
      }
      return PARENT;
    };

    Node.prototype.findOverlappingNodes = function(item) {
      if (item.x < this.x + (w / 2)) {
        if (item.y < this.y + (h / 2)) {
          TOP_LEFT;
        }
        if (item.y + item.h >= y + (h / 2)) {
          BOTTOM_LEFT;
        }
      }
      if (item.x + item.w >= this.x + (w / 2)) {
        if (item.y < this.y + (h / 2)) {
          TOP_RIGHT;
        }
        if (item.y + item.h >= this.y + (h / 2)) {
          return BOTTOM_RIGHT;
        }
      }
    };

    Node.prototype.divide = function() {
      var childDepth, height, i, j, oldChildren, ref, results, width;
      width = w / 2;
      height = h / 2;
      childDepth = this.depth + 1;
      this.nodes.push(node(this.x, this.y, width, height, childDepth, maxChildren, maxDepth));
      this.nodes.push(node(this.x + width, this.y, width, height, childDepth, maxChildren, maxDepth));
      this.nodes.push(node(this.x, this.y + height, width, height, childDepth, maxChildren, maxDepth));
      this.nodes.push(node(this.x + width, this.y + height, width, height, childDepth, maxChildren, maxDepth));
      oldChildren = children;
      this.children = [];
      results = [];
      for (i = j = 0, ref = oldChildren.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results.push(this.insert(oldChildren[i]));
      }
      return results;
    };

    Node.prototype.clear = function() {
      var i, j, ref, results;
      results = [];
      for (i = j = 0, ref = this.nodes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.nodes[i].clear();
        this.children.length = 0;
        results.push(this.nodes.length = 0);
      }
      return results;
    };

    Node.prototype.getNodes = function() {
      if (this.nodes.length) {
        return this.nodes;
      } else {
        return false;
      }
    };

    return Node;

  })();

  module.exports = Node;

}).call(this);
